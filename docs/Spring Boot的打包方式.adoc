= Spring Boot的打包方式

Spring Boot打包好的jar包可以通过``java -jar``命令直接启动，如果是个web应用，则应用启动时也会自动启动一个服务器，下面分析实现原理

== Spring Boot编译出来的jar包文件结构
一个普通的Java程序可以通过Maven插件打包一个可执行的jar：
[source,xml]
.pom.xml
----
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-jar-plugin</artifactId>
            <configuration>
                <archive>
                    <manifest>
                        <mainClass>com.dhf.app.Application</mainClass>
                    </manifest>
                </archive>
            </configuration>
        </plugin>
    </plugins>
</build>
----

打包完成的jar文件结构如下：
[indent=0]
.xxx.jar
----
.
├── META-INF
│   └── MANIFEST.MF
└── com
    └── dhf
        └── app
            └── Application.class
----

其中MANIFEST.MF文件内容如下：
[source,MF]
.MANIFEST.MF
----
Manifest-Version: 1.0
Archiver-Version: Plexus Archiver
Built-By: dhf
Created-By: Apache Maven 3.6.1
Build-Jdk: 1.8.0_191
Main-Class: com.dhf.app.Application
----

可以看到，该文件有一个``Main-Class``属性，当执行``java -jar``命令时，会调用该属性指定的类的``main``函数，这就是一个普通的可执行jar的启动原理

Spring Boot也是通过这种方式实现的jar包启动，但是上面的例子没有依赖其他的第三方jar包，如果依赖了则需要在执行``java -jar``命令时指定``-classpath``才能正常运行，而Spring Boot不需要，这是因为Spring Boot实现了jar in jar，打包出来的jar包中有其依赖的所有第三方jar包，这种jar也叫fat jar，打包一个fat jar包需要使用Spring Boot的一个Maven插件，配置如下：
[source,xml]
.pom.xml
----
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <executions>
                <execution>
                    <goals>
                        <goal>repackage</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
----

执行``mvn package``即可得到Spring Boot jar，一个简单的Spring Boot jar文件结构：
[indent=0]
xxx.jar
----
.
├── BOOT-INF
│   ├── classes
│   │   ├── application.yaml
│   │   └── org
│   │       └── springframework
│   │           └── boot
│   │               └── demo
│   │                   ├── DemoApplication.class
│   │                   └── controller
│   │                       └── DemoController.class
│   └── lib
│       ├── 所有依赖的jar
├── META-INF
│   └── MANIFEST.MF
└── org
    └── springframework
        └── boot
            └── loader
                ├── Spring Boot的spring-boot-loader模块类
----

其中文件内容如下：
[source,MF]
.MANIFEST.MF
----
Manifest-Version: 1.0
Implementation-Title: demo-project
Automatic-Module-Name: demo.project
Implementation-Version: 2.3.0.BUILD-SNAPSHOT
Built-By: Spring
Start-Class: org.springframework.boot.demo.DemoApplication
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Build-Jdk-Spec: 1.8
Spring-Boot-Version: 2.3.0.BUILD-SNAPSHOT
Created-By: Maven Jar Plugin 3.2.0
Main-Class: org.springframework.boot.loader.JarLauncher
----

可以看到``Main-Class``属性值为Spring Boot中的类，执行``java -jar``命令时，执行的是该类的``main``函数，值得注意的是``MANIFEST.MF``文件中还有一个``Start-Class``属性，值为Spring Boot应用程序的Application类，上面的Spring Boot应用程序本身的类保存在``BOOT-INF/classes``文件夹下，而运行时所需要的依赖都保存在了``BOOT-INF/lib``文件夹下，所以运行时需要的东西已经准备就绪了，下面看这个fat jar的运行过程